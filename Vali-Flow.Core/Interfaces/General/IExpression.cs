using System.Linq.Expressions;

namespace Vali_Flow.Core.Interfaces.General;

/// <summary>
/// Defines operations for building, adding conditions, and evaluating logical expressions for an entity of type <typeparamref name="T"/>.
/// </summary>
/// <typeparam name="TBuilder">The specific builder type that implements this interface.</typeparam>
/// <typeparam name="T">The type of the entity being evaluated.</typeparam>
public interface IExpression<out TBuilder,T>
{
    /// <summary>
    /// Builds a boolean expression from the added conditions.
    /// </summary>
    /// <returns>A boolean expression representing the evaluation of the added conditions.</returns>
    /// <example>
    /// <code>
    /// var builder = new ConditionBuilder();
    /// builder.Add(x => x.Age > 18).Add(x => x.Name == "John");
    /// var expression = builder.Build(); // The resulting expression represents the condition (Age > 18) AND (Name == "John")
    /// </code>
    /// </example>
    Expression<Func<T, bool>> Build();

    /// <summary>
    /// Builds a negated version of the condition generated by the <see cref="Build"/> method.
    /// </summary>
    /// <returns>
    /// An <see>
    ///     <cref>Expression{Func{T, bool}}</cref>
    /// </see>
    /// that represents the logical negation of the original condition.
    /// </returns>
    /// <remarks>
    /// This method retrieves the condition built by the <see cref="Build"/> method, then creates a new expression by applying the logical NOT operator
    /// to the body of the original expression. The resulting lambda expression returns <c>true</c> for elements that do not satisfy the original condition,
    /// and <c>false</c> for those that do.
    /// </remarks>
    Expression<Func<T, bool>> BuildNegated();

    /// <summary>
    /// Adds a condition to the list of conditions based on a boolean expression.
    /// </summary>
    /// <param name="expression">The expression to add, represented as a boolean expression.</param>
    /// <returns>The current builder to allow method chaining.</returns>
    /// <exception cref="ArgumentNullException">Throws an exception if the condition is null.</exception>
    /// <example>
    /// <code>
    /// var builder = new ConditionBuilder();
    /// builder.Add(x => x.Age > 18); // Adds a condition to check if the age is greater than 18
    /// </code>
    /// </example>
    TBuilder Add(Expression<Func<T, bool>> expression);

    /// <summary>
    /// Adds a condition to the list of conditions based on a specific property of the entity of type <typeparamref name="T"/>
    /// and a predicate that evaluates a value of type <typeparamref name="TValue"/>.
    /// </summary>
    /// <typeparam name="TValue">The type of the value to be evaluated.</typeparam>
    /// <param name="selector">Expression to select the attribute to work with</param>
    /// <param name="predicate">A boolean expression that evaluates the value selected by the <paramref name="predicate"/>.</param>
    /// <returns>The current builder to allow method chaining.</returns>
    /// <exception cref="ArgumentNullException">Throws an exception if any parameter is null.</exception>
    /// <example>
    /// <code>
    /// builder.Add(x => x.Age, age => age >= 18);
    /// </code>
    /// </example>
    TBuilder Add<TValue>(Expression<Func<T, TValue>> selector, Expression<Func<TValue, bool>> predicate);

    /// <summary>
    /// Adds a group of conditions that will be evaluated as a sub-expression.
    /// This group can be combined with other logical conditions such as AND or OR.
    /// </summary>
    /// <param name="group">The action that builds the group of conditions.</param>
    /// <returns>The current builder to allow method chaining.</returns>
    /// <example>
    /// <code>
    /// var builder = new ConditionBuilder();
    /// builder.AddSubGroup(group => group.Add(x => x.Age > 18).Add(x => x.Name == "John"));
    /// // This example adds a subgroup with conditions (Age > 18) AND (Name == "John")
    /// </code>
    /// </example>
    TBuilder AddSubGroup(Action<IExpression<TBuilder,T>> group);
    
    /// <summary>
    /// Defines a logical "AND" operation between conditions.
    /// </summary>
    /// <returns>The current builder to allow method chaining.</returns>
    /// <example>
    /// <code>
    /// var builder = new ConditionBuilder();
    /// builder.Add(x => x.Age > 18).And().Add(x => x.Name == "John");
    /// // The resulting expression will be (Age > 18) AND (Name == "John")
    /// </code>
    /// </example>  
    TBuilder And();

    /// <summary>
    /// Defines a logical "OR" operation between conditions.
    /// </summary>
    /// <returns>The current builder to allow method chaining.</returns>
    /// <example>
    /// <code>
    /// var builder = new ConditionBuilder();
    /// builder.Add(x => x.Age > 18).Or().Add(x => x.Name == "John");
    /// // The resulting expression will be (Age > 18) OR (Name == "John")
    /// </code>
    /// </example>
    TBuilder Or();
}